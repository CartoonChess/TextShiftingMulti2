<!DOCTYPE html>
<html>

<head>
    <title>Text Shifting</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="/socket.io/socket.io.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // Get player set up for remote connection
            // var socket = io();
            // Using default URL param
            const socket = io(window.location.host, { autoConnect: false });
            //socket.auth = { username: "joe" };
            // socket.connect();

            // `localStorage` is a property of browser `window`
            const sessionId = localStorage.getItem('sessionId');
            if (sessionId) {
                socket.auth = { sessionId };
                // socket.connect();
                updateConsole(`had seshId ${sessionId}.`)
            }
            
            // Not in the tutorial but
            // let's just try connecting down here instead
            socket.connect();

            // Get session ID, whether new or returning
            socket.on('session', ({ sessionId, userId }) => {
                // 'attach sessionId to next reconnection attempts'
                socket.auth = { sessionId };
                // Store in browser's localStorage
                localStorage.setItem('sessionId', sessionId);
                // Save (public) userId
                socket.userId = userId;
                updateConsole(`got userId ${socket.userId}.`);
            });

            // Not sure this actually works
            socket.on('connect_error', (err) => {
                var errorMessage = '(unknown error)';
                if (err.message) { errorMessage = err.message; }
                updateConsole(`ERROR: [Socket.io]: ${errorMessage}.`);
            });

            // socket.on('self connected', (id) => {
            //     updateConsole(`You're in (ID: ${id}).`);
            // });

            var socketConnectCount = 0;
            socket.on('connect', () => {
                socketConnectCount++;
                updateConsole(`Socket connect count: ${socketConnectCount}.`);
            });

            var socketDisonnectCount = 0;
            socket.on('disconnect', (reason) => {
                socketDisonnectCount++;
                updateConsole(`Socket disconnect count: ${socketDisonnectCount}. Reason: ${reason}.`);
            });

            // socket.on('users'...
            socket.on('all players', (allPlayers) => {
                updateConsole(`all players: ${JSON.stringify(allPlayers)}.`);
            });

            // socket.on('user connected'...
            socket.on('other connected', ({ userId }) => {
                updateConsole(`Friend's in (ID: ${userId}).`);
            });

            socket.on('other disconnected', (userId) => {
                updateConsole(`userId ${userId} left.`);
            });

            // Shouldn't be here
            const remotePlayer = new RemotePlayer('1');

            socket.on('move', (positionOnMap) => {
                // Convert from json back to Coordinate
                // remotePlayerPositionOnMap = Object.assign(new Coordinate, JSON.parse(positionOnMap));
                remotePlayer.position = Object.assign(new Coordinate, JSON.parse(positionOnMap));
                // if (remotePlayerWasRecentlyInView || remotePlayerIsInView()) {
                if (remotePlayer.wasInView || remotePlayer.isInView) {
                    updateText();
                }
            });

            // socket.on('private message'...
            socket.on('move2', ({ userId, position }) => {
                updateConsole(`${userId} moves to ${position}.`);
            });
            
            class Coordinate {
                constructor(column, line) {
                    this.column = column;
                    this.line = line;
                }
                toString() {
                    return `(x: ${this.column}, y: ${this.line})`;
                }
                // possibly provide some func/prop that provides .leftOfMe
            }

            class Direction {
                static Up = new Direction("up")
                static Down = new Direction("down")
                static Left = new Direction("left")
                static Right = new Direction("right")

                constructor(name) {
                    this.name = name;
                }
            }

            class Surroundings {
                constructor(lines, coordinate) {
                    if (lines && coordinate) {
                        this.update(lines, coordinate);
                    } else {
                        this.here = ' ';
                        this.up = ' ';
                        this.down = ' ';
                        this.left = ' ';
                        this.right = ' ';
                    }
                }
                update(lines, coordinate) {
                    const x = coordinate.column;
                    const y = coordinate.line;
                    this.here = lines[y][x];
                    this.up = lines[y - 1][x];
                    this.down = lines[y + 1][x];
                    this.left = lines[y][x - 1];
                    this.right = lines[y][x + 1];
                }
                toString() {
                    return ` ${this.up} \n${this.left}${this.here}${this.right}\n ${this.down} `;
                }
            }

            class Player {
                #position;
                get position() {
                    return new Coordinate(
                    currentPosition + screenCenter.column,
                    topArrayIndex + screenCenter.line);
                }
            }

            class RemotePlayer extends Player {
                // Private properties aren't inherited
                #position;
                #positionInView;
                #isInView;
                wasInView = true;
                
                constructor(id, position) {
                    this.id = id;
                    if (!position) {
                        position = new Coordinate(-1, -1);
                    }
                    this.#position = position;
                }
                get position() {
                    return this.#position;
                }
                set position(coordindate) {
                    this.#position = coordinate;
                }
                get positionInView() {
                    if (this.#isInView) {
                        // Convert remote player's position to viewport coord
                        return new Coordinate(
                            this.#position.column - currentPosition,
                            this.#position.line - topArrayIndex
                        );
                    } else {
                        return new Coordinate(-1, -1);
                    }
                }
                // This also updates wasInView
                get isInView() {
                    const isInXView = this.#position.column >= currentPosition && this.#position.column < currentPosition + numberOfColumns;
                    const isInYView = this.#position.line >= topArrayIndex && this.#position.line < topArrayIndex + numberOfLines;
                    this.wasInView = isInXView && isInYView;
                    return this.wasInView;
                }
            }

            function generateArrays(numberOfElements) {
                const arrays = [];

                for (let i = 0; i < numberOfElements; i++) {
                    const array = [];
                    for (let j = 0; j < numberOfElements; j++) {
                        const randomNumber = Math.random();
                        let character;

                        if (randomNumber < 0.65) {
                            character = ' ';
                        } else if (randomNumber < 0.8) {
                            character = '.';
                        } else if (randomNumber < 0.95) {
                            character = ',';
                        } else if (randomNumber < 0.99) {
                            character = ';';
                        } else {
                            character = '~';
                        }

                        array.push(character);
                    }
                    arrays.push(array);
                }
                return arrays;
            }


            // Full map
            var numberOfElements = 29;
            var arrays = generateArrays(numberOfElements);
            const mapCenter = new Coordinate(Math.floor(numberOfElements / 2), Math.floor(numberOfElements / 2));
            // Screen area
            var numberOfLines = 9;
            var numberOfColumns = 9;
            const screenCenter = new Coordinate(Math.floor(numberOfColumns / 2), Math.floor(numberOfLines / 2));
            // Current view
            var topArrayIndex = mapCenter.line - screenCenter.line;
            var currentPosition = mapCenter.column - screenCenter.column;
            const playerPosition = screenCenter; // syntactic sugar
            var playerSurroundings = new Surroundings();
            // Remote player (position refers to entire map, not viewport)
            var remotePlayerPositionOnMap = new Coordinate(-1, -1);
            var remotePlayerWasRecentlyInView = true;
            // Just for info purposes
            var textUpdateCount = 0;

            const player = new Player();
            const remotePlayers = [];

            // This will all be handled by socket 'all players' later
            // Make sure to remove self
            // remotePlayers.push({
            //     userId: session.userId
            // });
            

            function replaceCharAt(index, chr, str) {
                // If called as a func of string, operate on copy of String itself
                if (!str) {str = this;}
                if (index > str.length - 1) return str;
                return str.substring(0, index) + chr + str.substring(index + 1);
            }
            // Add this as a method on String
            String.prototype.replaceCharAt = replaceCharAt;

            function updateText() {
                updateConsole('updateText...');
                // const remotePlayer = getRemotePlayerPositionInView();
                const lines = [];
                for (let i = 0; i < numberOfLines; i++) {
                    lines[i] = arrays[topArrayIndex + i].slice(currentPosition, currentPosition + numberOfColumns).join('');
                    // Show @char at centre of both axes
                    if (i === playerPosition.line) {
                        lines[i] = lines[i].replaceCharAt(playerPosition.column, '@');
                    }
                    // Show %char for remote player
                    // if (i === remotePlayer.line) {
                    //     lines[i] = lines[i].replaceCharAt(remotePlayer.column, '%');
                    // }
                    if (i === remotePlayer.position.line) {
                        lines[i] = lines[i].replaceCharAt(remotePlayer.position.column, '%');
                    }
                    document.getElementById(`line${i}`).textContent = lines[i];
                }
                // Just toying around
                playerSurroundings.update(lines, playerPosition);
                updateConsole(`position: ${player.position}`);
                // textUpdateCount++;
                // updateConsole(textUpdateCount);
                // updateConsole(socket.id);
                // updateConsole(`ping: ${pingServer()}ms.`);
            }

            function canMove(direction) {
                switch (direction) {
                    case Direction.Up: {
                        return topArrayIndex > 0 && playerSurroundings.up != ';';
                        break;
                    }
                    case Direction.Down: {
                        return topArrayIndex + numberOfLines < arrays.length && playerSurroundings.down != ';';
                        break;
                    }
                    case Direction.Left: {
                        return currentPosition > 0 && playerSurroundings.left != ';';
                        break;
                    }
                    case Direction.Right: {
                        return currentPosition < numberOfElements - numberOfColumns && playerSurroundings.right != ';';
                        break;
                    }
                    default: {
                        // this should never happen
                    }
                }
            }

            function shiftRight() {
                if (canMove(Direction.Right)) {
                    currentPosition++;
                    updateText();
                    broadcastMove();
                }
            }

            function shiftLeft() {
                if (canMove(Direction.Left)) {
                    currentPosition--;
                    updateText();
                    broadcastMove();
                }
            }

            function switchArrayUp() {
                if (canMove(Direction.Up)) {
                    topArrayIndex--;
                    updateText();
                    broadcastMove();
                }
            }

            function switchArrayDown() {
                if (canMove(Direction.Down)) {
                    topArrayIndex++;
                    updateText();
                    broadcastMove();
                }
            }

            // Send position to other players
            function broadcastMove() {
                const positionOnMap = new Coordinate(
                    currentPosition + screenCenter.column,
                    topArrayIndex + screenCenter.line);
                // Should this be broadcast/other instead? Can it be?
                socket.emit('move', JSON.stringify(positionOnMap));
            }

            function pingServer() {
                const start = Date.now();
                socket.emit('latency', () => {
                    const duration = Date.now() - start;
                    return duration;
                });
            }

            function updateConsole(msg) {
                const debug = true;
                if (debug) {
                    msg = document.getElementById('console').textContent + `${msg}\n`;
                }
                document.getElementById('console').textContent = msg;
            }

            document.addEventListener('keydown', function (event) {
                if (event.key === 'ArrowRight') {
                    shiftRight();
                } else if (event.key === 'ArrowLeft') {
                    shiftLeft();
                } else if (event.key === 'ArrowUp') {
                    switchArrayUp();
                } else if (event.key === 'ArrowDown') {
                    switchArrayDown();
                }
            });

            // First load
            updateText();
            broadcastMove();

            function remotePlayerIsInView() {
                const remotePlayerIsWithinXView = remotePlayerPositionOnMap.column >= currentPosition && remotePlayerPositionOnMap.column < currentPosition + numberOfColumns;
                const remotePlayerIsWithinYView = remotePlayerPositionOnMap.line >= topArrayIndex && remotePlayerPositionOnMap.line < topArrayIndex + numberOfLines;
                const inView = remotePlayerIsWithinXView && remotePlayerIsWithinYView;
                remotePlayerWasRecentlyInView = inView;
                return inView;
            }
            
            function getRemotePlayerPositionInView() {
                if (remotePlayerIsInView()) {
                    // Convert remote player's position to viewport coord
                    return new Coordinate(
                        remotePlayerPositionOnMap.column - currentPosition,
                        remotePlayerPositionOnMap.line - topArrayIndex
                    );
                } else {
                    return new Coordinate(-1, -1);
                }
            }

            // Mobile

            // Ignore swipes so page won't move
            // Except this doesn't actually work
            // document.addEventListener("touchmove", function (event) {
            //     event.codeventDefault();
            // });

            // Now the actual swipes
            // Unfortunately Y isn't doing anything

            var initialX = null;
            var initialY = null;

            document.addEventListener("touchstart", function (event) {
                initialX = event.touches[0].clientX;
                initialY = event.touches[0].clientY;
            });

            document.addEventListener("touchend", function (event) {
                if (initialX !== null) {
                    var currentX = event.changedTouches[0].clientX;
                    var deltaX = currentX - initialX;
                    if (deltaX < 0) {
                        shiftLeft();
                    } else if (deltaX > 0) {
                        shiftRight();
                    }
                    initialX = null;
                }
                if (initialY !== null) {
                    var currentY = event.changedTouches[0].clientY;
                    var deltaY = currentY - initialY;
                    if (deltaY < 0) {
                        shiftDown();
                    } else if (deltaY > 0) {
                        shiftUp();
                    }
                    initialY = null;
                }
            });
        });
    </script>
    <style>
        body {
            overflow: hidden;
            /* Disable scrolling */
            touch-action: none;
            /* Disable touch events */
        }

        #console {
            /* keep multiplace spaces but still wrap */
            white-space: pre-wrap;
            margin-top: 15px;
            padding: 5px;
            background: #1e1e1e;
            color: #ffffff;
        }

        @media (prefers-color-scheme: dark) {
            html, body {
                background: #1e1e1e;
                color: #ffffff;
            }
            #console {
                background: #000000;
            }
        }
    </style>
</head>

<body>
    <pre>
        <code id="line0"></code>
        <code id="line1"></code>
        <code id="line2"></code>
        <code id="line3"></code>
        <code id="line4"></code>
        <code id="line5"></code>
        <code id="line6"></code>
        <code id="line7"></code>
        <code id="line8"></code>
    </pre>

    <pre id="console"></pre>
</body>

</html>